## API Report File for "@vue-kakuyaku/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Except } from 'type-fest';
import { MaybeRef } from '@vueuse/core';
import { Ref } from 'vue';
import { WatchOptions } from 'vue';
import { WatchSource } from 'vue';
import { WatchStopHandle } from 'vue';

// @public (undocumented)
export interface ComposedKey<K extends ScopeKey, P> {
    // (undocumented)
    key: K;
    // (undocumented)
    payload: P;
}

// @public (undocumented)
export interface Deferred<T> extends Promise<T> {
    // (undocumented)
    reject: (reason: unknown) => void;
    // (undocumented)
    resolve: (value: T | PromiseLike<T>) => void;
    // (undocumented)
    readonly state: 'pending' | 'fulfilled' | 'rejected';
}

// @public (undocumented)
export function deferred<T>(): Deferred<T>;

// @public (undocumented)
export interface DeferredScope<T> {
    // (undocumented)
    dispose: () => void;
    // (undocumented)
    scope: Readonly<Ref<null | ScopeExpose<T>>>;
    // (undocumented)
    setup: (fn: () => T) => void;
}

// @public (undocumented)
export function delay(ms: number): Promise<void>;

// @public (undocumented)
export interface ErrorRetryOptions {
    count?: MaybeRef<number>;
    interval?: MaybeRef<number>;
}

// @public (undocumented)
export type FalsyScopeKey = false | null | undefined;

// @public (undocumented)
export type FlatMode = 'all' | 'fulfilled' | 'rejected';

// @public (undocumented)
export function flattenState<T>(state: PromiseStateAtomic<T>): PromiseStateAtomicFlat<T, 'fulfilled'>;

// @public (undocumented)
export function flattenState<T, M extends FlatMode>(state: PromiseStateAtomic<T>, mode: M): PromiseStateAtomicFlat<T, M>;

// @public (undocumented)
export type KeyedScopeExpose<E, U extends UniScopeKey> = ScopeExpose<E> & SpreadKey<U>;

// @public (undocumented)
export type KeyOnly<U extends UniScopeKey> = U extends ComposedKey<infer K, any> ? K : U;

// @public (undocumented)
export type PromiseResultAtomic<T> = PromiseStateInvariantFulfilled<T> | PromiseStateInvariantRejected;

// @public (undocumented)
export interface PromiseStaleState<T> {
    // (undocumented)
    fresh: boolean;
    // (undocumented)
    fulfilled: null | {
        value: T;
    };
    // (undocumented)
    pending: boolean;
    // (undocumented)
    rejected: null | {
        reason: unknown;
    };
}

// @public (undocumented)
export type PromiseStateAtomic<T> = PromiseStateInvariantEmpty | PromiseStateInvariantPending | PromiseResultAtomic<T>;

// @public (undocumented)
export type PromiseStateAtomicFlat<T, M extends FlatMode> = PromiseStateInvariantEmpty | PromiseStateInvariantPending | PromiseStateInvariantFulfilledFlat<T, M> | PromiseStateInvariantRejectedFlat<M>;

// @public (undocumented)
export interface PromiseStateInvariantEmpty {
    // (undocumented)
    fulfilled: null;
    // (undocumented)
    pending: false;
    // (undocumented)
    rejected: null;
}

// @public (undocumented)
export interface PromiseStateInvariantFulfilled<T> {
    // (undocumented)
    fulfilled: {
        value: T;
    };
    // (undocumented)
    pending: false;
    // (undocumented)
    rejected: null;
}

// @public (undocumented)
export interface PromiseStateInvariantFulfilledFlat<T, M extends FlatMode> {
    // (undocumented)
    fulfilled: M extends 'all' | 'fulfilled' ? T : {
        value: T;
    };
    // (undocumented)
    pending: false;
    // (undocumented)
    rejected: null;
}

// @public (undocumented)
export interface PromiseStateInvariantPending {
    // (undocumented)
    fulfilled: null;
    // (undocumented)
    pending: true;
    // (undocumented)
    rejected: null;
}

// @public (undocumented)
export interface PromiseStateInvariantRejected {
    // (undocumented)
    fulfilled: null;
    // (undocumented)
    pending: false;
    // (undocumented)
    rejected: {
        reason: unknown;
    };
}

// @public (undocumented)
export interface PromiseStateInvariantRejectedFlat<M extends FlatMode> {
    // (undocumented)
    fulfilled: null;
    // (undocumented)
    pending: false;
    // (undocumented)
    rejected: M extends 'all' | 'rejected' ? unknown : {
        reason: unknown;
    };
}

// @public (undocumented)
export interface ScopeExpose<E> {
    // (undocumented)
    expose: E;
}

// @public
export type ScopeKey = string | number | symbol | true;

// @public (undocumented)
export type SpreadKey<U extends UniScopeKey> = U extends ComposedKey<infer K, infer P> ? {
    key: K;
    payload: P;
} : {
    key: U;
};

// @public (undocumented)
export type UniScopeKey = ScopeKey | ComposedKey<ScopeKey, any>;

// @public
export function useDeferredScope<T>(): DeferredScope<T>;

// @public (undocumented)
export function useErrorRetry(state: PromiseStateAtomic<unknown>, retry: () => void, options?: ErrorRetryOptions): {
    reset: () => void;
    retries: Ref<number>;
};

// @public (undocumented)
export function useParamScope<E, K extends UniScopeKey | FalsyScopeKey>(key: WatchSource<K>, setup: (resolvedKey: K extends UniScopeKey ? K : never) => E): Ref<K extends UniScopeKey ? (K extends true ? ScopeExpose<E> : KeyedScopeExpose<E, K>) : null>;

// @public (undocumented)
export function usePromise<T>(): UsePromiseReturn<T>;

// @public (undocumented)
export interface UsePromiseReturn<T> {
    // (undocumented)
    clear: () => void;
    // (undocumented)
    set: (promise: Promise<T>) => void;
    // (undocumented)
    state: PromiseStateAtomic<T>;
}

// @public (undocumented)
export function useStaleState<T>(state: PromiseStateAtomic<T>): PromiseStaleState<T>;

// @public
export function useTask<T>(fn: () => Promise<T>, options?: {
    immediate: boolean;
}): {
    state: PromiseStateAtomic<T>;
    run: () => void;
    clear: () => void;
};

// @public (undocumented)
export function wheneverDone<T>(state: PromiseStateAtomic<T>, fn: (result: PromiseResultAtomic<T>) => void, options?: WheneverPromiseOptions): WatchStopHandle;

// @public (undocumented)
export function wheneverFulfilled<T>(state: PromiseStateAtomic<T>, fn: (value: T) => void, options?: WheneverPromiseOptions): WatchStopHandle;

// @public (undocumented)
export type WheneverPromiseOptions = Except<WatchOptions, 'deep'>;

// @public (undocumented)
export function wheneverRejected(state: PromiseStateAtomic<unknown>, fn: (reason: unknown) => void, options?: WheneverPromiseOptions): WatchStopHandle;

// (No @packageDocumentation comment for this package)

```
