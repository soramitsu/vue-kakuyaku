## API Report File for "@vue-kakuyaku/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Except } from 'type-fest';
import { MaybeRef } from '@vueuse/core';
import { Ref } from 'vue';
import { WatchOptions } from 'vue';
import { WatchStopHandle } from 'vue';

// @public (undocumented)
export interface ComposedKey<K extends ScopeKey, P> {
    // (undocumented)
    key: K;
    // (undocumented)
    payload: P;
}

// @public (undocumented)
export interface Deferred<T> extends Promise<T> {
    // (undocumented)
    reject: (reason: unknown) => void;
    // (undocumented)
    resolve: (value: T | PromiseLike<T>) => void;
    // (undocumented)
    readonly state: 'pending' | 'fulfilled' | 'rejected';
}

// @public (undocumented)
export function deferred<T>(): Deferred<T>;

// @public (undocumented)
export interface DeferredScope<T> {
    // (undocumented)
    dispose: () => void;
    // (undocumented)
    scope: Readonly<Ref<null | ScopeExpose<T>>>;
    // (undocumented)
    setup: (fn: () => T) => void;
}

// @public (undocumented)
export function delay(ms: number): Promise<void>;

// @public (undocumented)
export interface ErrorRetryOptions {
    count?: MaybeRef<number>;
    interval?: MaybeRef<number>;
}

// @public (undocumented)
export type FalsyScopeKey = false | null | undefined;

// Warning: (ae-forgotten-export) The symbol "PromiseStateAtomicFlat" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export function flattenState<T>(state: PromiseStateAtomic<T>): PromiseStateAtomicFlat<T, 'fulfilled'>;

// Warning: (ae-forgotten-export) The symbol "FlatMode" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export function flattenState<T, M extends FlatMode = 'fulfilled'>(state: PromiseStateAtomic<T>, mode: M): PromiseStateAtomicFlat<T, M>;

// @public (undocumented)
export type PromiseResultAtomic<T> = PromiseStateInvariantFulfilled<T> | PromiseStateInvariantRejected;

// @public (undocumented)
export interface PromiseStaleState<T> {
    // (undocumented)
    fresh: boolean;
    // (undocumented)
    fulfilled: null | {
        value: T;
    };
    // (undocumented)
    pending: boolean;
    // (undocumented)
    rejected: null | {
        reason: unknown;
    };
}

// @public (undocumented)
export type PromiseStateAtomic<T> = PromiseStateInvariantEmpty | PromiseStateInvariantPending | PromiseResultAtomic<T>;

// @public (undocumented)
export interface PromiseStateInvariantEmpty {
    // (undocumented)
    fulfilled: null;
    // (undocumented)
    pending: false;
    // (undocumented)
    rejected: null;
}

// @public (undocumented)
export interface PromiseStateInvariantFulfilled<T> {
    // (undocumented)
    fulfilled: {
        value: T;
    };
    // (undocumented)
    pending: false;
    // (undocumented)
    rejected: null;
}

// @public (undocumented)
export interface PromiseStateInvariantPending {
    // (undocumented)
    fulfilled: null;
    // (undocumented)
    pending: true;
    // (undocumented)
    rejected: null;
}

// @public (undocumented)
export interface PromiseStateInvariantRejected {
    // (undocumented)
    fulfilled: null;
    // (undocumented)
    pending: false;
    // (undocumented)
    rejected: {
        reason: unknown;
    };
}

// @public (undocumented)
export interface ScopeExpose<T> {
    // (undocumented)
    expose: T;
}

// @public (undocumented)
export interface ScopeExposeWithComposedKey<T, K extends ScopeKey, P> extends ScopeExposeWithKey<T, K> {
    // (undocumented)
    payload: P;
}

// @public (undocumented)
export interface ScopeExposeWithKey<T, K extends ScopeKey> extends ScopeExpose<T> {
    // (undocumented)
    key: K;
}

// @public
export type ScopeKey = string | number | symbol;

// @public
export function useDeferredScope<T>(): DeferredScope<T>;

// @public (undocumented)
export function useErrorRetry(state: PromiseStateAtomic<unknown>, retry: () => void, options?: ErrorRetryOptions): {
    reset: () => void;
    retries: Ref<number>;
};

// @public (undocumented)
export function useParamScope<E>(key: Ref<boolean>, setup: () => E): Ref<null | ScopeExpose<E>>;

// @public (undocumented)
export function useParamScope<E, K extends ScopeKey>(key: Ref<K>, setup: (key: K) => E): Ref<ScopeExposeWithKey<E, K>>;

// @public (undocumented)
export function useParamScope<E, K extends ScopeKey>(key: Ref<K>, setup: (key: K) => E): Ref<ScopeExposeWithKey<E, K>>;

// @public (undocumented)
export function useParamScope<E, K extends ScopeKey>(key: Ref<FalsyScopeKey | K>, setup: (key: K) => E): Ref<null | ScopeExposeWithKey<E, K>>;

// @public (undocumented)
export function useParamScope<E, K extends ScopeKey, P>(key: Ref<ComposedKey<K, P>>, setup: (payload: P) => E): Ref<ScopeExposeWithComposedKey<E, K, P>>;

// @public (undocumented)
export function useParamScope<E, K extends ScopeKey, P>(key: Ref<FalsyScopeKey | ComposedKey<K, P>>, setup: (payload: P) => E): Ref<null | ScopeExposeWithComposedKey<E, K, P>>;

// @public (undocumented)
export function usePromise<T>(): UsePromiseReturn<T>;

// @public (undocumented)
export interface UsePromiseReturn<T> {
    // (undocumented)
    clear: () => void;
    // (undocumented)
    set: (promise: Promise<T>) => void;
    // (undocumented)
    state: PromiseStateAtomic<T>;
}

// @public (undocumented)
export function useScopeWithAdvancedKey<K extends string | number | symbol, P, S>(key: Ref<null | {
    key: K;
    payload: P;
}>, fn: (payload: P) => S): Ref<null | {
    expose: S;
    key: K;
    payload: P;
}>;

// @public (undocumented)
export function useStaleState<T>(state: PromiseStateAtomic<T>): PromiseStaleState<T>;

// @public
export function useTask<T>(fn: () => Promise<T>, options?: {
    immediate: boolean;
}): {
    state: PromiseStateAtomic<T>;
    run: () => void;
    clear: () => void;
};

// @public (undocumented)
export function wheneverDone<T>(state: PromiseStateAtomic<T>, fn: (result: PromiseResultAtomic<T>) => void, options?: WheneverPromiseOptions): WatchStopHandle;

// @public (undocumented)
export function wheneverFulfilled<T>(state: PromiseStateAtomic<T>, fn: (value: T) => void, options?: WheneverPromiseOptions): WatchStopHandle;

// @public (undocumented)
export type WheneverPromiseOptions = Except<WatchOptions, 'deep'>;

// @public (undocumented)
export function wheneverRejected(state: PromiseStateAtomic<unknown>, fn: (reason: unknown) => void, options?: WheneverPromiseOptions): WatchStopHandle;

// (No @packageDocumentation comment for this package)

```
