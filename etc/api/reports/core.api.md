## API Report File for "@vue-kakuyaku/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { MaybeRef } from '@vueuse/core';
import { Ref } from 'vue';
import { WatchOptions } from 'vue';
import { WatchStopHandle } from 'vue';

// @public
export class BareTask<T> {
    constructor(fn: TaskFn<T>);
    // (undocumented)
    abort(): void;
    // (undocumented)
    run(): Promise<BareTaskRunReturn<T>>;
}

// @public (undocumented)
export type BareTaskRunReturn<T> = TaskStateAborted | Result<T>;

// @public (undocumented)
export interface DanglingScope<T> {
    // (undocumented)
    dispose: () => void;
    // (undocumented)
    scope: Readonly<Ref<null | ScopeSetup<T>>>;
    // (undocumented)
    setup: (fn: () => T) => void;
}

// @public (undocumented)
export interface ErrorRetryOptions {
    count?: MaybeRef<number>;
    interval?: MaybeRef<number>;
}

// @public (undocumented)
export type FalsyScopeKey = false | null | undefined;

// @public (undocumented)
export interface KeyedScopeSetup<T, K extends ScopeKey> extends ScopeSetup<T> {
    // (undocumented)
    key: K;
}

// @public (undocumented)
export type Maybe<T> = null | {
    some: T;
};

// @public (undocumented)
export type OnAbortFn = (fn: () => void) => void;

// @public
export type Result<T> = ResultOk<T> | ResultErr;

// @public
export interface ResultErr extends Tagged<'err'> {
    // (undocumented)
    readonly error: unknown;
}

// @public
export interface ResultOk<T> extends Tagged<'ok'> {
    // (undocumented)
    readonly data: T;
}

// @public
export type ScopeKey = string | number | symbol;

// @public (undocumented)
export interface ScopeSetup<T> {
    // (undocumented)
    setup: T;
}

// @public
export interface Tagged<T extends string> {
    // (undocumented)
    readonly kind: T;
}

// @public
export interface Task<T> {
    // (undocumented)
    abort: () => void;
    // (undocumented)
    run: () => Promise<BareTaskRunReturn<T>>;
    state: TaskState<T>;
}

// @public
export type TaskFn<T> = (onAbort: OnAbortFn) => Promise<T>;

// @public (undocumented)
export interface TaskStaleIfErrorState<T> {
    // (undocumented)
    error: Maybe<unknown>;
    // (undocumented)
    fresh: boolean;
    // (undocumented)
    pending: boolean;
    // (undocumented)
    result: Maybe<T>;
}

// @public
export type TaskState<T> = TaskStateUninit | TaskStatePending | Result<T> | TaskStateAborted;

// @public
export interface TaskStateAborted extends Tagged<'aborted'> {
}

// @public
export interface TaskStatePending extends Tagged<'pending'> {
}

// @public
export interface TaskStateUninit extends Tagged<'uninit'> {
}

// @public
export function useDanglingScope<T>(): DanglingScope<T>;

// @public (undocumented)
export function useErrorRetry(task: Task<any>, options?: ErrorRetryOptions): {
    reset: () => void;
    retries: Ref<number>;
};

// @public (undocumented)
export function useLastTaskResult<T>(task: Task<T>): Ref<null | Result<T>>;

// @public
export function useScope<T>(cond: Ref<boolean>, setup: () => T): Ref<null | ScopeSetup<T>>;

// @public (undocumented)
export function useScope<T, K extends ScopeKey>(key: Ref<K>, setup: (key: K) => T): Ref<KeyedScopeSetup<T, K>>;

// @public (undocumented)
export function useScope<T, K extends ScopeKey>(condKey: Ref<FalsyScopeKey | K>, setup: (key: K) => T): Ref<null | KeyedScopeSetup<T, K>>;

// @public (undocumented)
export function useStaleIfErrorState<T>(task: Task<T>): TaskStaleIfErrorState<T>;

// Warning: (ae-unresolved-link) The @link reference could not be resolved: The reference is ambiguous because "useScope" has more than one declaration; you need to add a TSDoc member reference selector
//
// @public
export function useTask<T>(fn: TaskFn<T>): Task<T>;

// @public (undocumented)
export function wheneverTaskErrors(task: Task<unknown>, fn: (error: unknown) => void, options?: WatchOptions): WatchStopHandle;

// @public (undocumented)
export function wheneverTaskSucceeds<T>(task: Task<T>, fn: (result: T) => void, options?: WatchOptions): WatchStopHandle;

// (No @packageDocumentation comment for this package)

```
